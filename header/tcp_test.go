package header

import (
	"testing"
)

// func TestTCPHeader(t *testing.T) {
// 	tests := []struct {
// 		raw        []byte
// 		srcPort    uint16
// 		dstPort    uint16
// 		headerLen  int
// 		dataOffset uint8
// 	}{}
// }

func TestTCPHeader_SrcPort(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint16
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			50271,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			50143,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got, _ := header.SrcPort()
		if got != test.want {
			t.Errorf("test[%d] : got=%d, wanted=%d", i, got, test.want)
		}
	}
}

func TestTCPHeader_SetSrcPort(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint16
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			50271,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			50143,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		header.SetSrcPort(test.want)
		got, _ := header.SrcPort()
		if got != test.want {
			t.Errorf("test[%d] : got=%d, wanted=%d", i, got, test.want)
		}
	}
}

func TestTCPHeader_DstPort(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint16
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			8080,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			443,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got, _ := header.DstPort()
		if got != test.want {
			t.Errorf("test[%d] : got=%d, wanted=%d", i, got, test.want)
		}
	}
}

func TestTCPHeader_SetDstPort(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint16
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			8080,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			443,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		header.SetDstPort(test.want)
		got, _ := header.DstPort()
		if got != test.want {
			t.Errorf("test[%d] : got=%d, wanted=%d", i, got, test.want)
		}
	}
}

func TestTCPHeader_SeqNum(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint32
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			0xa6c90e45,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			0x06b5f198,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.SeqNum()
		if got != test.want {
			t.Errorf("test[%d] : got=%X, wanted=%X", i, got, test.want)
		}
	}
}

func TestTCPHeader_AckNum(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint32
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			0x0,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			0xbdc6ba6a,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.AckNum()
		if got != test.want {
			t.Errorf("test[%d] : got=%X, wanted=%X", i, got, test.want)
		}
	}
}

func TestTCPHeader_DataOffset(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint8
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			8,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			5,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.DataOffset()
		if got != test.want {
			t.Errorf("test[%d] : got=%d, wanted=%d", i, got, test.want)
		}
	}
}

func TestTCPHeader_HeaderLen(t *testing.T) {
	tests := []struct {
		raw  []byte
		want int
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			32,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			20,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.HeaderLen()
		if got != test.want {
			t.Errorf("test[%d] : got=%d, wanted=%d", i, got, test.want)
		}
	}
}

func TestTCPHeader_Reserved(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint8
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90,
				0xa6, 0xc9, 0x0e, 0x45,
				0x00, 0x00, 0x00, 0x00,
				0x80, 0x02, 0xfa, 0xf0,
				0x4e, 0xee, 0x00, 0x00,
				0x02, 0x04, 0x05, 0xb4,
				0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			0,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x5A, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			5,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.Reserved()
		if got != test.want {
			t.Errorf("test[%d] : got=%d, wanted=%d", i, got, test.want)
		}
	}
}

func TestTCPHeader_Window(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint16
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			0xfaf0,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x5A, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			0xfaf0,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.Window()
		if got != test.want {
			t.Errorf("test[%d] : got=%X, wanted=%X", i, got, test.want)
		}
	}
}

func TestTCPHeader_Checksum(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint16
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x00, 0x00, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			0x4eee,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x5A, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			0xa403,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.Checksum()
		if got != test.want {
			t.Errorf("test[%d] : got=%X, wanted=%X", i, got, test.want)
		}
	}
}

func TestTCPHeader_UrgPtr(t *testing.T) {
	tests := []struct {
		raw  []byte
		want uint16
	}{
		{
			[]byte{0xc4, 0x5f, 0x1f, 0x90, 0xa6, 0xc9, 0x0e, 0x45, 0x00, 0x00, 0x00, 0x00, 0x80, 0x02, 0xfa, 0xf0, 0x4e, 0xee, 0x40, 0x02, 0x02, 0x04, 0x05, 0xb4, 0x01, 0x03, 0x03, 0x08, 0x01, 0x01, 0x04, 0x02},
			0x4002,
		},
		{
			[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x5A, 0x10, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			0x0,
		},
	}
	for i, test := range tests {
		header := NewTCPHeader(test.raw)
		got := header.UrgPtr()
		if got != test.want {
			t.Errorf("test[%d] : got=%X, wanted=%X", i, got, test.want)
		}
	}
}

func TestTCPHeader_Flags(t *testing.T) {
	tests := []struct {
		raw []byte
		ns  bool
		cwr bool
		ece bool
		urg bool
		ack bool
		psh bool
		rst bool
		syn bool
		fin bool
	}{
		{[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x5F, 0xFF, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			true, true, true, true, true, true, true, true, true,
		},
		{[]byte{0xc3, 0xdf, 0x01, 0xbb, 0x06, 0xb5, 0xf1, 0x98, 0xbd, 0xc6, 0xba, 0x6a, 0x50, 0x00, 0xfa, 0xf0, 0xa4, 0x03, 0x00, 0x00},
			false, false, false, false, false, false, false, false, false,
		},
	}

	for i, test := range tests {
		header := NewTCPHeader(test.raw)

		ns := header.NS()
		if ns != test.ns {
			t.Errorf("test[%d] - NS: got=%v, wanted=%v", i, ns, test.ns)
		}
		cwr := header.CWR()
		if cwr != test.cwr {
			t.Errorf("test[%d] - CWR : got=%v, wanted=%v", i, cwr, test.cwr)
		}
		ece := header.ECE()
		if ece != test.ece {
			t.Errorf("test[%d] - ECE : got=%v, wanted=%v", i, ece, test.ece)
		}
		urg := header.URG()
		if urg != test.urg {
			t.Errorf("test[%d] - URG : got=%v, wanted=%v", i, urg, test.urg)
		}
		ack := header.ACK()
		if ns != test.ns {
			t.Errorf("test[%d] - ACK : got=%v, wanted=%v", i, ack, test.ack)
		}
		psh := header.PSH()
		if ns != test.ns {
			t.Errorf("test[%d] - PSH : got=%v, wanted=%v", i, psh, test.psh)
		}
		rst := header.RST()
		if ns != test.ns {
			t.Errorf("test[%d] - RST : got=%v, wanted=%v", i, rst, test.rst)
		}
		syn := header.SYN()
		if ns != test.ns {
			t.Errorf("test[%d] - SYN : got=%v, wanted=%v", i, syn, test.syn)
		}
		fin := header.FIN()
		if ns != test.ns {
			t.Errorf("test[%d] - FIN: got=%v, wanted=%v", i, fin, test.fin)
		}

	}
}
